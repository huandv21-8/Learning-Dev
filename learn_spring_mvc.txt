

*********** Java EE ********
- "Java EE" tên đầy đủ là "Java Enterprise Edition" dịch sang tiếng việt có nghĩa là là "Java Phiên Bản Doanh Nghiệp",
 nó là một nền tảng (platform) dành cho việc xây dựng các ứng dụng (application) cấp doanh nghiệp.



********** SPRING **********
- Spring Framework là một khung Java EE được sử dụng rộng rãi để xây dựng các ứng dụng.
	+ Spring boot là 1 module của Spring framework được sử dụng rộng rãi để phát triển các REST APIs.
	+ Spring MVC là 1 module của Spring framework với mục đích chính của nó là xây dựng các ứng dụng web dựa trên mô hình MVC (Model - View - Controller)


********** Mô hình three tiers ************
     - 3-Tiers có tính vật lý (physical): là mô hình client-server (mỗi tier có thể đặt chung 1 nơi hoặc nhiều nơi, kết nối với nhau qua Web services, WCF, Remoting...).
        + Presentation tier bao gồm các thành phần phần xử lý giao diện Graphic User Interface (GUI)
        + Business tier gồm các thành phần Business Logic Layer (BLL), Data Access Layer (DAL) và Data Tranfer Object (DTO): xem thêm phần 3-layers
        + Data tier lưu trữ dữ liệu, là các hệ quản trị CSDL như MS SQL Server, Oracle, SQLite, MS Access, XML files, text files,...
		
**************************
 - sitemesh decorator : tùy chỉnh giao diện
 
 ************************** SPRING *******************************
 - Spring Framework cung cấp khoảng 20 mô-đun có thể được sử dụng dựa trên yêu cầu ứng dụng: data access/ integration, web(mvc/remoting), core container
 - Hibernate là một triển khai của JPA và sử dụng kỹ thuật ORM.
 - Dependency injection : là khi người dùng có 1 class mà họ ko cần khai báo class đó nhưng họ có thể tiêm các giá trị cho các biến trong  các class đó.
 - IoC là nơi chứa class mà cho phép các bạn tiêm vào.
 - CÓ 3 cách tạo bean: + dùng @Configuration
                       + dùng @Controller, @Service , @Repository, @Controller
					   + dùng file xml.
 - @Bean:  Mỗi bean đại diện cho một đối tượng, được lưu trong IoC
 - vòng đời bean: init-method và destroy-method;
    + init-method: tụ động chạy khi file bean đc load
	+ destroy-method: chạy khi context được đóng.
 - @autowired : Tự động nhúng các bean được Spring Container sinh ra vào Class có khai báo @Autowire
 - @Configuration : @Configuration sẽ khai báo một hoặc nhiều @Bean method trong class đó
 - @component: khi run project thì spring sẽ chạy qua hết các class có anotation @component và lưu các bean vào kho chứa (IoC)
 - @ComponentScan: để thông báo Spring Container biết phải vào package nào trong dự án để quét các Annotation và tạo Bean. 
    ví dụ : @ComponentScan(basePackages = "levunguyen.spring ")   // Spring sẽ quét tất cả các file trong package levunguyen.spring
	        Tìm các Class có annotation để tạo bean và các @autowire để nhúng bean ở trong container vào các Class sử dụng autowire
 - @scope: @Scope ở đây là phạm vi bean được sinh và và bị phá huỷ dưới sự quản lý của Spring Container
 - @controller: Một class được đánh dấu là @Controller thì để khai báo Class đó là một controller và có nhiệm vụ mapping request trên url vào các method tương ứng trong controller.
 - @RequestMapping: Có nhiệm vụ ánh xạ các request (yêu cầu) người dùng vào method tương ứng trong controller.
 - @ModelAttribute: Chúng ta sử dụng ModelAttribute như một cầu nối giữa Controller và View. Từ Controller chúng ta truyền các dữ liệu qua cho View thông qua ModelAttribute.
 - @SessionAttribute: Chúng ta sử dụng @SessionAttribute để lưu trữ các giá trị trong một phiên làm việc
 
 ****************design pattern****************************
Design Patterns - Factory Pattern
Design Patterns - Singleton Pattern
Design Patterns - Composite Pattern
Design Patterns - Facade Pattern
Design Patterns - MVC Pattern
Design Patterns - Observer pattern
Design Patterns - Strategy Pattern
Design Patterns - Repository Pattern
 
- Signleton pattern:  tạo 1 đối tượng dùng xuyên suốt trong dự án.
- Composite Pattern : cây thư mục:
   ví dụ: public class Employee {
      private String name;
      private int salary;
      private List<Employee> subordinates; (đây là cây thư mục) }
- Factory Pattern: giống tính đa hình trong oop
- Facede pattern: 



********Rest Api/ Soap Api***************
-khác nhau:
 +rest: gọi api đc bên fontend,  api có thể giống nhau (khác method), dữ liệu thường trả về là json
 +soap: chỉ gọi đc bên Backend, ko hỗ trợ các method, dữ liệu trả về là xml
 
 
********** Hibernate ****************
   -sessionFactory : hỗ trợ khởi tạo đối tượng session
   -session : là đối tượng dùng để hỗ trợ tạo và thực thi câu lệnh sql
   
   
************ authen vs author *******************
 - Authentication (Who you are ? ) là xác thực, chỉ quá trình định danh (hay xác định) một tài khoản đang vào hệ thống chính là người đó chứ không phải ai khác
 - Authorization (What you can do ? ) là danh tính, xác định role của người mà đã được authen, xem họ có chức năng gì, và được phép làm gì trong hệ thống.
 
 
 
**********JWT******************
	- Bao gồm 3 phần
		+ Header : lưu trữ dữ liệu liên quan đến token như thuật toán, loại mã, định dạng,... để tạo ra token
		+ Payload: lưu trữ thông tin người dùng như email, role, name, ...
		+ Signature (optional): giúp chúng ta xác thực danh tính người gửi, để tạo ra một signature chính xác, ta cần encode phần header, phần payload,
 
 **********spring security************
   - example: https://github.com/eazybytes/springsecurity6
 
  - client -> các filter( filter -> filterChainProxy -> filter -> .... ) -> (controller, service, repository)
	 -> lấy ra username/pass chuyển thành object authentication 
	 -> gửi cho authentication manager ( sẽ quản lý logic xác thực, và kiểm tra authentication providers có trong ứng dụng web của ta ( quản lý authentication providers) ) 
	 -> Nhiệm vụ của các authentication providers là xác thực thông tin ( có thể có nhiều authentication providers) 
	 -> Nếu sử dụng authentication providers mặc định của spring security thì sẽ nhận được sự trợ giúp của UserDetailManager/Service và PaswordEncoder
	 -> UserDetailManager/Service và PaswordEncoder (mã hóa mật khẩu ) sẽ làm việc cùng nhau để xác định liệu thông tin xác thực nhất định của người dùng cuối có hợp lệ hay không.
	 -> Theo đó sẽ cho authentication provider biết có hợp lệ hay không 
	 -> bàn giao lại cho authentication manager 
	 -> tiếp đến là các lớp filters (spring security filters)
	 -> trước khi phải hồi lại cho người dùng cuối thì sẽ lưu trữ đối tượng (object authentication ) ở bước 2 vào security context
	 -> Và từ yêu cầu thứ 2 trở đi người dùng sẽ không cần nhập thông tin đăng nhập nếu xác thực thành công ở trong giai đoạn đầu ( đó là mục đích của bước lưu thông tin vào security context)
	 
	 
	 Vì vậy, trách nhiệm của người quản lý xác thực là xác định tất cả các nhà cung cấp xác thực có sẵn cho yêu cầu cụ thể này. Và theo đó, nó sẽ gửi yêu cầu đến các nhà cung cấp xác thực này cho đến khi đạt đến điểm xác thực thành công hoặc xác thực thất bại.
Vì vậy, trình quản lý xác thực của tôi sẽ không chỉ gửi yêu cầu đến một trong những nhà cung cấp xác thực, giả sử nghĩ đến một tình huống nó gửi yêu cầu đến nhà cung cấp xác thực đầu tiên và xác thực không thành công. 
Vì vậy, trong trường hợp này, trình quản lý xác thực của tôi
sẽ không chỉ trả lại phản hồi cho người dùng cuối nói rằng thông tin đăng nhập của bạn không thành công. Thay vào đó, nó sẽ thử với tất cả các nhà cung cấp xác thực có sẵn. Vì vậy, khi nó thử tất cả các nhà cung cấp xác thực và không ai trong số họ được xác thực thành công thì chỉ có trình quản lý xác thực của tôi sẽ phản hồi cho người dùng cuối rằng xác thực của bạn không thành công.
 Đó là vai trò của người quản lý xác thực và đối với nhà cung cấp xác thực mà chúng ta có thể thấy ở đây, có thể có nhiều nhà cung cấp xác thực.
 
- UserDetailsService (interface): có phương thức trừu tượng là loadUserByUsername: lấy thông tin của người dùng từ DB theo username được nhập để so sánh với chi tiết người dùng được lưu trong hệ thống
- UserDetailsManager (interface)extends UserDetailsService: có thể cập nhật thông tin người dùng ( thêm, sửa, xóa,..)
- UserDetails là interface: 
- @PreAuthorize: kiểm tra username, role của người dùng có đúng không thì sẽ đc thực thi method
- @PostAuthorize: kiểm tra giá trị chả về của method có đúng với giá trị người dùng login không (vẫn thực thi method)
- @PreFilter: lọc các đối tượng đầu vào ( trước khi thực thi method)
- @PosFilter: lọc các đối tượng đầu vào (sau khi thực thi method)

********CORS vs CSRF*********
	CORS: cross origin resource sharing ( là tính năng bảo vệ của trình duyệt)
		nguồn gốc (origin) là một url gồm giao thức (http, https,...), tên miền (domain) và số cổng( port number )
		2 nguồn gốc khác nhau khi 1 trong các tiêu chí trên khác nhau -> dẫn đến lỗi CORS
		Giả sử nếu hai ứng dụng khác nhau đang cố gắng giao tiếp với nhau thì chắc chắn nguồn gốc của chúng sẽ khác nhau vì số cổng sẽ khác hoặc tên máy chủ sẽ khác hoặc giao thức HTTP có thể khác nhau hoặc tất cả chúng có thể khác nhau vì chúng là những ứng dụng rất khác nhau được triển khai trên các máy chủ khác nhau.
	
	CSRF: cross site request forgery
		chèn các đoạn mã scrip nhằm thay đổi thông tin DB, từ đó hacker có chiếm đoạt được tài khoản
		

*******OAUTH***********

	 Docs: https://topdev.vn/blog/oauth2-la-gi/
	 Demo: https://www.oauth.com/playground/index.html
	 Login with GG: https://developers.google.com/identity/protocol/oauth2
	 
	 
	 Ví dụ: ứng dụng của mình đang muốn login bằng tài khoản fb
		Client: ứng dụng của mình
		Owner/user: là (mình) người ủy quyền cho phép ứng dụng client để truy cập vào tài khoản của mình trên fb
		Authorization server (fb): chứng thực yêu cầu từ phía ứng dụng của mình 
		Resource server (fb): chứa tài nguyên được chia sẻ
		+ Cách hoạt động:
			 người dùng click vào đăng nhập
			 chuyển đến trang login của fb
			 đăng nhập fb
			 fb xác thực thông tin đăng nhập và trả về cho ứng dụng của mình đoạn authorization code
			 ứng dụng của mình sẽ gửi thông tin định danh (ID) và kèm theo authorization code tới fb
			 fb xác thực thông tin ứng dụng của mình vừa gửi
			 nếu hợp lệ thì fb sẽ trả access token cho ứng dụng của mình
			 ứng dụng của mình gửi access token tới resource server (fb)
			 nếu hợp lệ sẽ trả tài nguyên tương ứng cho ứng dụng của mình
		Grant type: 




*******OpenID connect (OIDC) vs OAuth2 ***********
	 OIDC được xây dựng dựa trên OAuth2 và mở rộng các tính năng của nó để hỗ trợ xác thực người dùng.
	 OIDC: được thiết kế để xác thực người dùng (authentication), tức là xác định danh tính của người dùng đang truy cập vào ứng dụng.
	 OAuth2: chủ yếu nhằm mục đích ủy quyền (authorization), cho phép client truy cập vào tài nguyên của người dùng mà không cần biết mật khẩu của họ.
	 OIDC sử dụng ID token (dưới dạng JWT) để đại diện cho thông tin về danh tính của người dùng. ID token được trả về từ authorization server sau khi người dùng đồng ý chia sẻ thông tin cá nhân và quyền truy cập tài nguyên với client
	 OAuth2 không cung cấp ID token. Thay vào đó, nó sử dụng access token để ủy quyền truy cập tài nguyên.
	 OIDC sử dụng một số scopes đặc biệt, chẳng hạn như "openid", "profile", "email" và "address", để yêu cầu thông tin người dùng cụ thể từ authorization server.
	 OAuth2 được sử dụng để yêu cầu quyền truy cập vào tài nguyên cụ thể từ người dùng.



 
 
 
 
 
 
 
 
 
 
 
